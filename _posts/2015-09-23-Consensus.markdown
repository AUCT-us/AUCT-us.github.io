---
layout: post
title:  "It looks like we might have consensus!"
date:   2015-09-23 8:30:00
categories: algorithms social leadership
---
I enjoy and am frustrated by the topic of CONSENSUS enough that I once started writing a book once about it ... [Plato's Republicans](http://www.platosrepublicans.com/) ... my interest in political economics and social choice theory gradually was overcome by the more concrete and practical world of consensus algorithms for distributed databases ... although I continue to see BOTH topics as very closely related, but I now see that the implementations of the distributed database algorithms offers much more promise than the theoretic navel-gazing of political economics and the even more abstract topic of how leaders form, seize, shape, manipulate, define consensus ... *if you thought consensus algorithms were difficult.*

This is a techblog so my focus in this post is upon an exploration of consensus algorithms in distributed databases.  In these RT/FT algorithms as in life with humans, it is easy to recognize what consensus is after you are there ... everyone loves it and we almost declare some sort of moral triumph when we exclaim, "So we have consensus!" ... but the pain of converging on the final solution can be a bugger ... especially if speed of convergence matters.

[Paxos](https://en.wikipedia.org/wiki/Paxos_(computer_science)) ... first published in 1989, named after a fictional legislative consensus system used on the Paxos island in Greece. The Paxos family of protocols includes a spectrum of trade-offs between the number of processors, number of message delays before learning the agreed value, the activity level of individual participants, number of messages sent, and types of failures. Although no deterministic fault-tolerant consensus protocol can guarantee progress in an asynchronous network, Paxos guarantees safety (consistency), and the conditions that could prevent it from making progress are difficult to provoke. Paxos is usually used where durability is required (for example, to replicate a file or a database), in which the amount of durable state could be large. The protocol attempts to make progress even during periods when some bounded number of replicas are unresponsive. There is also a mechanism to drop a permanently failed replica or to add a new replica.

[Chandra-Toueg](https://en.wikipedia.org/wiki/Chandra%E2%80%93Toueg_consensus_algorithm) ... published by Tushar Deepak Chandra and Sam Toueg in 1996, is an algorithm for solving consensus in a network of unreliable processes equipped with an eventually strong failure detector. The failure detector is an abstract version of timeouts; it signals to each process when other processes may have crashed. An eventually strong failure detector is one that never identifies some specific good process as having failed after some initial period of confusion, and at the same time eventually identifies all bad processes as failed. The algorithm itself is similar to the Paxos algorithm, which also relies on failure detectors. Both algorithms assume the number of faulty processes is less than n/2, where n is the total number of processes.

[Raft](https://raft.github.io/) ... first published in 2013 by [Diego Ongaro](https://ongardie.net/) and [John Osterhout](http://web.stanford.edu/~ouster/cgi-bin/home.php) is a understandable, more readily-implementable consensus algorithm designed as a more [practical alternative to famously difficult Paxos algorithm](http://www.cl.cam.ac.uk/~ms705/pub/papers/2015-osr-raft.pdf). According to Ongaro, [Raft was DESIGNED AT EVERY STEP TO BE MORE UNDERSTANDABLE](https://www.youtube.com/watch?v=6bBggO6KN_k) than Paxos or Chandra-Toueg algorithms by means of separation of logic, but it is also formally proven safe and offers some new features. Raft offers a generic way to distribute a state machine across a cluster of computing systems, ensuring that each node in the cluster agrees upon the same series of state transitions.  Although Raft is a recent development, it already has a number of open-source reference implementations, with full-spec implementations in Go, C++, Java, and Scala.


Reading list ...

* TBD accelerated social consensus research ... *like the rest of this reading list, this is glaringly incomplete* especially given the material that should be out there on NEW forms of social leadership ... what does social graph research tell us about the emergence of leader candidates; can the heuristic selection of leaders be applied to algorithms?  One would think that surely the voluminous research afforded by all of the social graph data from Twitter, FB and LinkedIn have taught us at least as much about nuances in the selection of Leaders and how followers aggregate as the [Byzantine Generals](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance) ever taught us about fault-tolerance, right... consider also Bitcoin and [other cultural phenomena, such as the bandwagon effect](https://en.wikipedia.org/wiki/Bandwagon_effect) ... as one might expect in industries where social interaction threatens the dominant regime, there are some [really thorough, CRITICAL systematic reviews of the effects of online peer to peer interactions in healthcare](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC411092/).

* TBD consensus algorithm dissertations and peer-reviewed papers ... another glaringly incomplete bullet point ... [A Formal Approach to Fault Tolerant Distributed Consensus](http://lampwww.epfl.ch/~blackbal/Thesis/thesis.pdf)

* [Google's Spanner](http://research.google.com/archive/spanner.html) [pdf](http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf), [slides](http://research.google.com/archive/spanner-osdi2012.pptx), [2012 talk at OSDI](http://livestream.com/accounts/1545775/osdi12/videos/4646642) Spanner is Google's scalable, multi-version, globally-distributed, and synchronously-replicated database. It is the first system to distribute data at global scale and support externally-consistent distributed transactions. This paper describes how Spanner is structured, its feature set, the rationale underlying various design decisions, and a novel time API that exposes clock uncertainty. This API and its implementation are critical to supporting external consistency and a variety of powerful features: non-blocking reads in the past, lock-free read-only transactions, and atomic schema changes, across all of Spanner.

* [Google Cloud Datastore balances strong and eventual consistency](https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore/) ... achieving strong consistency for a positive user experience while leveraging the eventual consistency model to scale to large datasets. Eventual consistency is a theoretical guarantee that, provided no new updates to an entity are made, all reads of the entity will eventually return the last updated value. The Internet Domain Name System (DNS) is a well-known example of a system with an eventual consistency model. DNS servers do not necessarily reflect the latest values but, rather, the values are cached and replicated across many directories over the Internet. It takes a certain amount of time to replicate modified values to all DNS clients and servers. However, the DNS system is a very successful system that has become one of the foundations of the Internet. It is highly available and has proven to be extremely scalable, enabling name lookups to over a hundred million devices across the entire Internet.  [Eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) services are often classified as providing BASE (Basically Available, Soft state, Eventual consistency) semantics, in contrast to traditional ACID (Atomicity, Consistency, Isolation, Durability) guarantees. Eventual consistency is sometimes criticized as increasing the complexity of distributed software applications. This is partly because eventual consistency is purely a liveness guarantee (reads eventually return the same value) and does not make safety guarantees: an eventually consistent system can return any value before it converges.  [The CAP theorem](http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed) asserts that any net­worked shared-data system can have only two of three desirable properties. How­ever, by explicitly handling partitions, designers can optimize consistency and availability, thereby achieving some trade-off of all three.

* TBD ... video playlists

* [RocksDB](https://github.com/facebook/rocksdb)

* [FoundationDB](https://en.wikipedia.org/wiki/FoundationDB) ... the *consensus* is that [Apple is not about to become an open source company](http://www.forbes.com/sites/benkepes/2015/03/25/a-cautionary-open-source-tale-apple-buys-and-shutters-foundationdb/)

* Extended blogosphere and twittersphere TBD

* MORE repository TBD
